map & filter:
___________________________	
-def add_five(x):
	return x+5
nums=[11, 22, 33, 44, 55]
result=list(map(add_five, nums))
print(result)		+> 	[16,27.38.49,60]

-by using lambda syntax;
nums=[11,22,33,44,55]
result=list(map(lambda x: x+5, nums))
print(result)

exL:
salaries = [2000,1800,3100,4400,1500]
bonus=int(input())
salaries=list(map(lambda x: x+bonus, salaries))
print(salaries)
_________________________
filter:
The function filter - filters an iterable by leaving only the items that match a condition(also called a predicate)/

np. \
nums=[11,22,33,44,55]
res=list(filter(lambda x: x%2==0, nums))
print(res)		+> [22, 44]


-all less than 5\
nums=[1,2,5,8,3,0,7]
res=list(filter(lambda x: x<5, nums))
print(res)
________________________________________________________
GENERATORS:
type of iterable, like lists or tuples. 
 - they dont allow indexing with arbitrary indices, but they still can be iterated through with for loops.
 - can be created using functions & yield statement.
 
ex:/
def countdown():
	i=5;
	while i>0:
		yield i
		i -= 1
for i in countdown():
	print(i)				= [ horizontal(poziom) 	vertical(pion) ] 54321 - printed line by line(vertically).
// The YIELD statement is used to define a generator, replacing the return of a function to provide a result to its caller without destroying local variables.


ex2:/ //Due to the fact that they yield one item at a time, generators don't have the memory restrictions of lists.
In fact, they can be infinite!
`def infinite_sevens():
	while True:
		yield 7
for i in infinite_sevens():
	print(i)		>>> 7777777777777777777777 ...	(Vertically).